---
title: Fluidity vs. Rigidity
date: 2023-08-31T10:45:12.000Z
draft: false
tags:
  - fluidity
  - rigidity
  - ergodicity
  - adaptation
  - resilience
  - systems thinking
  - physics
  - philosophy
  - flexibility
  - survival
---
In a world of constant change and uncertainty, the metaphors of fluidity and rigidity offer powerful lenses for understanding systems, structures, and human behavior. This exploration goes beyond physical properties to reveal how these opposing approaches shape our response to challenges, determine system resilience, and ultimately influence our success in navigating life's complexities. From physics to finance, from engineering to personal adaptation, the tension between flowing with change and resisting it defines our reality in profound ways.

## The Nature of Fluidity

A fluid is anything that _flows_, which includes gasses and liquids. Some
fluids even exhibit both properties of solids and liquids, such as in response
to shocks (i.e., [water with corn
starch](https://en.wikipedia.org/wiki/Non-Newtonian_fluid#Oobleck), a
"non-Newtonian fluid"). Ketchup is an example of a substance that does the
opposite: it exhibits solid properties until it's disturbed, after which it
flows, which is why shaking or pounding on the bottom of an upturned bottle of
ketchup will make it pour out.

<div id="fluid-simulation" class="font-source-sans-3 w-full h-[200px] my-5 bg-black dark:bg-gray-900 relative overflow-hidden rounded-lg"></div>

## Understanding Rigidity

{{< video autoplay="true" loop="true" src="base-isolation.mp4" classes="sm:max-w-[16rem] sm:float-left sm:ml-0 sm:mr-4 my-1" >}}
Rigidity is resistance to flow. To be rigid means you respond to shocks by
pushing back, rather than changing shape or getting out of the way. The problem
with rigidity is that while it provides the appearance of strength, failures of
rigid systems and structures are catastrophic. Properly engineered structures
(bridges, buildings, roads, etc.) need to be mostly rigid, but simultaneously
provide enough give and take that they don't explode when a small breeze comes
along, or in the event of an extreme shock like an earthquake, avoid total collapse.

The video above demonstrates base isolation technology, where buildings are designed with flexibility at their foundation to absorb seismic energy during earthquakes—a perfect example of engineered flexibility within an otherwise rigid structure.

## Rigidity in Complex Systems

In markets and economics, we find similar patterns. Rigid financial systems often blow up
when exposed to shocks, which sometimes result in bailouts from governments and
central banks to protect from so-called "contagion" (i.e., spreading cracks can
cause other rigid systems to collapse). The 2008 financial crisis exemplified this, with rigid mortgage-backed securities failing catastrophically when housing prices declined.

Contemporary examples abound. The COVID-19 pandemic exposed rigid supply chains that collapsed when faced with sudden demand shifts and transportation disruptions. Companies with rigid work policies struggled to adapt to remote operations, while more fluid organizations pivoted quickly. Tesla's manufacturing approach, which integrates vertical supply chains and rapid design iteration, demonstrated greater resilience than traditional automakers with rigid, outsourced supply networks.

Some substances are _incredibly_ rigid, to the point where they become brittle,
and may shatter when stressed. Examples of this are glass or hard plastic,
which—as you have likely experienced in your life—will shatter when dropped or
smashed. It's possible to harden glass or plastic, but with enough force
applied, [even the hardest substances will eventually
shatter](https://youtu.be/XBjiEsAyNQs?t=92). These substances are still
incredibly useful, but we know to carefully handle objects subject to such
failures.

## The Mathematics of Fluidity: Ergodicity

To be fluid means to adapt, overcome, diffuse, and take the shape of the
container. [Ergodicity](https://en.wikipedia.org/wiki/Ergodicity) is the
mathematical term for this concept, and it has some fascinating real-life
implications.

Ergodicity comes from the Greek words "ergon" (work) and "hodos" (path), essentially meaning "the same path for all." While it sounds complex, the core idea is surprisingly intuitive: in an ergodic system, the behavior of a single element over a long time resembles the behavior of many elements over a short time.

Imagine a jar filled with gas molecules. You could either:

1. Track one molecule as it bounces around for an hour, recording all the positions it visits
2. Take a snapshot of all molecules' positions at a single moment

In an ergodic system, these two approaches give you essentially the same information about where molecules tend to be found. The time average (one molecule over time) equals the space average (many molecules at once).

In simple terms, proving ergodicity allows us to consider small
samples as representative of the whole, which provides an opportunity to obtain
results by sampling.

This has profound implications for how we understand chance and probability in our lives. Consider these examples:

- **Weather forecasting**: Instead of waiting 100 years to see if a prediction model works, meteorologists can test it on 100 different regions simultaneously.

- **Market research**: Rather than testing a product on one person for years, companies test it briefly on thousands of people.

- **Evolution**: Nature doesn't need to test one genetic variation over millions of years—it tests millions of variations simultaneously across populations.

The advantage of fluidity as it relates to ergodicity and life is that you
don't necessarily need to experience the whole of anything in its entirety; a
sufficiently sized sample will do. For example, you don't need to become an
Olympic athlete to find out if you're good enough for the Olympics: you only
need to play the sport a few times (or for a few seasons) to see if you're
better or worse than your peers, or to figure out if you even enjoy it.

However, not all systems are ergodic. Non-ergodic systems are those where single instances can have dramatically different outcomes than the average. Think of a casino game where one massive loss can wipe you out completely—the average outcome across many players might be small losses, but your individual path matters enormously. These are systems where rigidity often emerges, as individual elements (people, institutions) try to protect themselves from catastrophic outcomes.

Understanding ergodicity helps us recognize when we can safely sample and adapt (fluid approach) versus when we need to be more cautious about individual paths (potentially requiring more rigid safeguards).

## The Inevitable Failure of Rigid Systems

Rigid systems will almost always blow up when exposed to unexpected or unplanned
shocks. The cure for poorly designed rigid systems is to allow them to blow up,
because it makes sure those systems no longer exist, and you're only left with
fluid systems. Failure is nature's way of getting rid of the bad stuff.

<div id="beam-simulation" class="font-source-sans-3 w-full h-[300px] my-5 bg-gray-100 dark:bg-gray-800 relative overflow-hidden rounded-lg border border-gray-300 dark:border-gray-700"></div>

### Abraham Wald and the Missing Bullet Holes

During World War II, the Statistical Research Group (SRG) at Columbia University was tasked with helping the war effort through statistical analysis. Abraham Wald, a brilliant Jewish mathematician who had fled Nazi-occupied Austria, was among their ranks.

One of the problems presented to the SRG was how to better protect bombers from enemy fire. Military officers showed them diagrams of returning aircraft, with bullet holes clustered primarily in the fuselage and wings. Their initial inclination was obvious: reinforce these heavily damaged areas with more armor.

But Wald saw something the officers missed. He realized they were only examining planes that had _survived_ combat and made it back to base. The bullet holes showed where a plane could be hit and still return safely. The areas without damage—primarily the engines and control systems—were the truly vulnerable spots. Planes hit in those areas weren't returning at all.

This insight led to one of the most famous examples of [survivorship bias](https://en.wikipedia.org/wiki/Survivorship_bias#Military) in history. Wald recommended armoring the areas that showed _no_ bullet holes on the returning planes, contrary to intuition.

This exemplifies the danger of rigid thinking. The military's initial approach was to react directly to what they could see (reinforce where bullets hit), representing a rigid response to information. Wald's fluid thinking allowed him to consider what wasn't immediately visible—the planes that never returned—and adapt his recommendation accordingly.

Modern applications of this principle abound:

- Successful entrepreneurs often study business failures, not just successes
- Effective medical treatments emerge from understanding why certain patients don't respond to therapy
- Resilient software systems are designed by anticipating failure modes, not just optimizing for normal operation

The rigidity of focusing only on "survivors" leads to deeply flawed systems. The fluid approach of considering the full spectrum of outcomes—including those that never make it back to tell their tale—creates truly resilient designs.

## Where Fluid Meets Rigid

Fluid systems only blow up where they meet the rigid parts, which is typically
around joints or interfaces that haven't been properly designed to cope with
stresses. Interestingly, the fluid parts of the system tend to help absorb
shocks anyway, which makes tolerances much higher in a partially fluid system,
rather than a strictly rigid system. Nature demonstrates this principle repeatedly—consider how trees bend in high winds rather than snap, or how our bodies use fluid-filled joints to absorb impact.

A striking contemporary example is Netflix's approach to system reliability. Their "Chaos Monkey" deliberately introduces failures into their production systems to ensure they're designed to handle disruptions fluidly. By contrast, companies with rigid approaches to reliability often experience catastrophic outages when unexpected failures cascade through their systems.

## Human Adaptation: Rigidity vs. Fluidity

Rigid people struggle to adapt as the world changes around them, when they
experience hardship, or when things don't go their way. Those who are rigid
expect authority to step in and save them, as opposed to learning to help
themselves. Rigid people tend not to survive in a world where survival is all
that counts.

People who are fluid go with the flow, they understand that nothing lasts
forever, they adapt to the world around them, and they fill the container
they're in. Fluid people don't bother fighting the trends—as much as they may
not like them—and they learn to take advantage of opportunities. Those who are
fluid understand that success in life is mostly about luck, but that you can
increase your luck by working to maximize exposure to opportunities and making
asymmetric upside bets where the downside is limited.

## Developing Fluid Thinking

### Practical Strategies for Cultivating Adaptability

1. **Practice deliberate exposure to change**: Intentionally alter routines and approaches to build your capacity to adapt.

2. **Adopt the beginner's mind**: Even in areas of expertise, maintain openness to new perspectives and approaches.

3. **Develop scenario thinking**: Regularly imagine various futures and how you might adapt to each.

4. **Build diverse networks**: Connect with people across different fields and backgrounds to expand your mental models.

5. **Implement small, reversible experiments**: Test ideas with minimal commitment before scaling them.

6. **Study systems outside your domain**: Biological, social, and technical systems offer transferable insights about adaptation.

7. **Practice active recovery**: After setbacks, analyze what happened, extract lessons, and adapt your approach rather than rigidly persisting.

8. **Balance structure and flexibility**: Create frameworks that provide guidance while allowing for adaptation as conditions change.

These approaches are supported by research in cognitive flexibility, system resilience, and adaptive expertise. Books like Nassim Taleb's _Antifragile_, Carol Dweck's _Mindset_, and Peter Senge's _The Fifth Discipline_ offer deeper dives into these concepts.

## Conclusion: the Dance of Fluidity and Rigidity

The tension between fluidity and rigidity isn't just a physical or philosophical curiosity—it's a fundamental dynamic that shapes how systems and people survive and thrive. Complete rigidity leads to catastrophic failure when facing the inevitable unexpected shock. Yet pure fluidity without structure lacks direction and purpose.

The most successful systems—whether natural ecosystems, human organizations, or personal approaches to life—balance these opposing forces. They incorporate enough structure to maintain identity and purpose, while preserving sufficient adaptability to bend rather than break when challenged.

As we face a world of accelerating change and increasing complexity, developing this balance becomes ever more crucial. The wisest approach might be to cultivate what Bruce Lee famously advised: "Be water, my friend." Flow around obstacles, adapt to containers, and when necessary, wear away even the hardest stone through persistent, patient action.

By understanding these dynamics, we can design more resilient systems, build more adaptive organizations, and develop more successful approaches to navigating our complex, ever-changing world.

## Further Reading

- Taleb, Nassim Nicholas. (2012). _Antifragile: Things That Gain from Disorder_. Random House.
- Meadows, Donella H. (2008). _Thinking in Systems: A Primer_. Chelsea Green Publishing.
- Gunderson, Lance H. & Holling, C.S. (2001). _Panarchy: Understanding Transformations in Human and Natural Systems_. Island Press.
- Dweck, Carol S. (2006). _Mindset: The New Psychology of Success_. Random House.
- Senge, Peter M. (1990). _The Fifth Discipline: The Art & Practice of The Learning Organization_. Doubleday.

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Common utility functions
  function isDarkMode() {
    return document.documentElement.classList.contains('dark');
  }

  function getThemeColors() {
    return {
      background: isDarkMode() ? '#1f2937' : '#f5f5f5',
      rigid: isDarkMode() ? '#ef4444' : '#e74c3c',
      flexible: isDarkMode() ? '#3b82f6' : '#3498db',
      text: isDarkMode() ? '#e5e7eb' : '#333333',
      pillar: isDarkMode() ? '#4b5563' : '#7f8c8d',
      force: isDarkMode() ? '#f97316' : '#e67e22',
      brokenRigid: isDarkMode() ? '#991b1b' : '#c0392b',
      brokenFlexible: isDarkMode() ? '#1e3a8a' : '#2980b9',
      gray: isDarkMode() ? '#6b7280' : '#999999'
    };
  }

  // Common event listener setup for theme changes
  function setupThemeChangeListener(callback) {
    const appearanceSwitchers = document.querySelectorAll('[id^="appearance-switcher"]');
    appearanceSwitchers.forEach(switcher => {
      switcher.addEventListener('click', function() {
        setTimeout(callback, 50);
      });
    });
  }

  // Beam Simulation
  const beamContainer = document.getElementById('beam-simulation');
  const beamCanvas = document.createElement('canvas');
  beamCanvas.width = beamContainer.clientWidth;
  beamCanvas.height = beamContainer.clientHeight;
  beamCanvas.className = "w-full h-full";
  beamContainer.appendChild(beamCanvas);
  const beamCtx = beamCanvas.getContext('2d');

  // Beam parameters
  const beamLength = beamCanvas.width * 0.35;
  const beamHeight = 15;
  const beamY = beamCanvas.height * 0.35;
  const pillarWidth = 20;
  const pillarHeight = 60;

  let colors = getThemeColors();

  // Beam objects
  const rigidBeam = {
    x: beamCanvas.width * 0.15,
    y: beamY,
    width: beamLength,
    height: beamHeight,
    color: colors.rigid,
    name: 'Rigid',
    broken: false,
    maxDeflection: 10,
    breakPoint: 60,
    segments: 20,
    points: []
  };

  const flexibleBeam = {
    x: beamCanvas.width * 0.55,
    y: beamY,
    width: beamLength,
    height: beamHeight,
    color: colors.flexible,
    name: 'Flexible',
    broken: false,
    maxDeflection: 40,
    breakPoint: 95,
    segments: 20,
    points: []
  };

  // Initialize beam points
  function initBeamPoints(beam) {
    beam.points = [];
    const segmentWidth = beam.width / beam.segments;

    for (let i = 0; i <= beam.segments; i++) {
      beam.points.push({
        x: beam.x + i * segmentWidth,
        y: beam.y,
        originalY: beam.y
      });
    }
  }

  initBeamPoints(rigidBeam);
  initBeamPoints(flexibleBeam);

  // Beam drawing functions
  function drawPillar(x, y, width, height) {
    beamCtx.fillStyle = colors.pillar;
    beamCtx.fillRect(x, y, width, height);
  }

  function drawBeam(beam) {
    beamCtx.strokeStyle = beam.broken ?
      (beam.name === 'Rigid' ? colors.brokenRigid : colors.brokenFlexible) :
      beam.color;
    beamCtx.lineWidth = beam.height;
    beamCtx.lineJoin = 'round';

    beamCtx.beginPath();
    beamCtx.moveTo(beam.points[0].x, beam.points[0].y);

    for (let i = 1; i <= beam.segments; i++) {
      beamCtx.lineTo(beam.points[i].x, beam.points[i].y);
    }

    beamCtx.stroke();

    if (beam.broken && beam.name === 'Rigid') {
      const middleIndex = Math.floor(beam.segments / 2);
      const midX = beam.points[middleIndex].x;
      const midY = beam.points[middleIndex].y;

      beamCtx.strokeStyle = isDarkMode() ? '#fff' : '#000';
      beamCtx.lineWidth = 2;

      beamCtx.beginPath();
      beamCtx.moveTo(midX - 10, midY - beam.height/2);
      beamCtx.lineTo(midX + 5, midY);
      beamCtx.lineTo(midX - 5, midY + 5);
      beamCtx.lineTo(midX + 10, midY + beam.height/2);
      beamCtx.stroke();
    }
  }

  function drawForce(beam, forcePercent) {
    const middleIndex = Math.floor(beam.segments / 2);
    const midX = beam.points[middleIndex].x;
    const midY = beam.points[middleIndex].y - beam.height/2 - 10;
    const arrowLength = 20 + (forcePercent / 100) * 30;

    beamCtx.strokeStyle = colors.force;
    beamCtx.fillStyle = colors.force;
    beamCtx.lineWidth = 2;

    beamCtx.beginPath();
    beamCtx.moveTo(midX, midY - arrowLength);
    beamCtx.lineTo(midX, midY);
    beamCtx.stroke();

    beamCtx.beginPath();
    beamCtx.moveTo(midX, midY);
    beamCtx.lineTo(midX - 5, midY - 10);
    beamCtx.lineTo(midX + 5, midY - 10);
    beamCtx.closePath();
    beamCtx.fill();

    beamCtx.fillStyle = colors.text;
    beamCtx.font = '12px Arial';
    beamCtx.textAlign = 'center';
    beamCtx.fillText(`${forcePercent}%`, midX, midY - arrowLength - 5);
  }

  function drawLabel(beam) {
    beamCtx.fillStyle = beam.broken ? colors.gray : beam.color;
    beamCtx.font = 'bold 14px Arial';
    beamCtx.textAlign = 'center';
    beamCtx.fillText(beam.name + ' Structure', beam.x + beam.width/2, beam.y - 75);
  }

  function drawStatus(beam, text) {
    beamCtx.fillStyle = beam.name === 'Rigid' ? colors.brokenRigid : colors.brokenFlexible;
    beamCtx.font = 'bold 12px Arial';
    beamCtx.textAlign = 'center';
    beamCtx.fillText(text, beam.x + beam.width/2, beam.y - 40);
  }

  function draw() {
    beamCtx.clearRect(0, 0, beamCanvas.width, beamCanvas.height);
    beamCtx.fillStyle = colors.background;
    beamCtx.fillRect(0, 0, beamCanvas.width, beamCanvas.height);

    drawPillar(rigidBeam.x, rigidBeam.y + rigidBeam.height, pillarWidth, pillarHeight);
    drawPillar(rigidBeam.x + rigidBeam.width - pillarWidth, rigidBeam.y + rigidBeam.height, pillarWidth, pillarHeight);
    drawPillar(flexibleBeam.x, flexibleBeam.y + flexibleBeam.height, pillarWidth, pillarHeight);
    drawPillar(flexibleBeam.x + flexibleBeam.width - pillarWidth, flexibleBeam.y + flexibleBeam.height, pillarWidth, pillarHeight);

    drawBeam(rigidBeam);
    drawBeam(flexibleBeam);

    const forcePercent = parseInt(slider.value);
    if (forcePercent > 0) {
      drawForce(rigidBeam, forcePercent);
      drawForce(flexibleBeam, forcePercent);
    }

    drawLabel(rigidBeam);
    drawLabel(flexibleBeam);

    if (rigidBeam.broken) drawStatus(rigidBeam, "CATASTROPHIC FAILURE");
    if (flexibleBeam.broken) drawStatus(flexibleBeam, "BENDING BUT INTACT");
  }

  // Beam control panel
  const controlPanel = document.createElement('div');
  controlPanel.className = "absolute bottom-4 left-0 w-full text-center px-1.5";
  beamContainer.appendChild(controlPanel);

  const sliderContainer = document.createElement('div');
  sliderContainer.className = "mb-4 text-center w-4/5 mx-auto";

  const sliderLabel = document.createElement('label');
  sliderLabel.htmlFor = 'force-slider';
  sliderLabel.className = "text-gray-700 dark:text-gray-300 mr-2.5";
  sliderLabel.textContent = 'Applied Force:';
  sliderContainer.appendChild(sliderLabel);

  const slider = document.createElement('input');
  slider.type = 'range';
  slider.min = '0';
  slider.max = '100';
  slider.value = '0';
  slider.id = 'force-slider';
  slider.className = "w-3/5 align-middle";
  sliderContainer.appendChild(slider);

  const valueDisplay = document.createElement('span');
  valueDisplay.textContent = '0%';
  valueDisplay.className = "ml-2.5 text-gray-700 dark:text-gray-300 font-bold";
  sliderContainer.appendChild(valueDisplay);

  controlPanel.appendChild(sliderContainer);

  const resetBtn = document.createElement('button');
  resetBtn.textContent = 'Reset';
  resetBtn.className = "py-1.5 px-4 mt-2 bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white border-none rounded cursor-pointer";
  controlPanel.appendChild(resetBtn);

  function reset() {
    slider.value = 0;
    valueDisplay.textContent = '0%';
    rigidBeam.broken = false;
    flexibleBeam.broken = false;
    initBeamPoints(rigidBeam);
    initBeamPoints(flexibleBeam);
    colors = getThemeColors();
    rigidBeam.color = colors.rigid;
    flexibleBeam.color = colors.flexible;
    draw();
  }

  function updateBeams(forcePercent) {
    // Update rigid beam
    if (forcePercent >= rigidBeam.breakPoint && !rigidBeam.broken) {
      rigidBeam.broken = true;
      const middleIndex = Math.floor(rigidBeam.segments / 2);
      for (let i = 0; i <= middleIndex; i++) {
        const ratio = i / middleIndex;
        rigidBeam.points[i].y = rigidBeam.points[i].originalY + 50 * ratio;
      }
      for (let i = middleIndex + 1; i <= rigidBeam.segments; i++) {
        const ratio = (rigidBeam.segments - i) / (rigidBeam.segments - middleIndex - 1);
        rigidBeam.points[i].y = rigidBeam.points[i].originalY + 50 * ratio;
      }
    } else if (!rigidBeam.broken) {
      const maxDeflection = (forcePercent / 100) * rigidBeam.maxDeflection;
      for (let i = 0; i <= rigidBeam.segments; i++) {
        const x = i / rigidBeam.segments;
        const deflection = maxDeflection * 4 * x * (1 - x);
        rigidBeam.points[i].y = rigidBeam.points[i].originalY + deflection;
      }
    }

    // Update flexible beam
    if (forcePercent >= flexibleBeam.breakPoint && !flexibleBeam.broken) {
      flexibleBeam.broken = true;
      const maxDeflection = flexibleBeam.maxDeflection * 1.5;
      for (let i = 0; i <= flexibleBeam.segments; i++) {
        const x = i / flexibleBeam.segments;
        const deflection = maxDeflection * 4 * x * (1 - x);
        flexibleBeam.points[i].y = flexibleBeam.points[i].originalY + deflection;
      }
    } else if (!flexibleBeam.broken) {
      const maxDeflection = (forcePercent / 100) * flexibleBeam.maxDeflection;
      for (let i = 0; i <= flexibleBeam.segments; i++) {
        const x = i / flexibleBeam.segments;
        const deflection = maxDeflection * 4 * x * (1 - x);
        flexibleBeam.points[i].y = flexibleBeam.points[i].originalY + deflection;
      }
    }

    draw();
  }

  slider.addEventListener('input', function() {
    valueDisplay.textContent = this.value + '%';
    updateBeams(parseInt(this.value));
  });

  resetBtn.addEventListener('click', reset);

  // Fluid Simulation
  const fluidContainer = document.getElementById('fluid-simulation');
  const fluidCanvas = document.createElement('canvas');
  fluidCanvas.width = fluidContainer.clientWidth;
  fluidCanvas.height = fluidContainer.clientHeight;
  fluidCanvas.className = "w-full h-full";
  fluidContainer.appendChild(fluidCanvas);
  const fluidCtx = fluidCanvas.getContext('2d');
  const particles = [];
  const particleCount = 200;

  function getParticleColor() {
    if (isDarkMode()) {
      return `rgba(56, 189, 248, ${Math.random() * 0.5 + 0.4})`;
    } else {
      return `rgba(0, 150, 255, ${Math.random() * 0.5 + 0.3})`;
    }
  }

  function createParticles() {
    particles.length = 0;
    for (let i = 0; i < particleCount; i++) {
      particles.push({
        x: Math.random() * fluidCanvas.width,
        y: Math.random() * fluidCanvas.height,
        radius: Math.random() * 3 + 1,
        color: getParticleColor(),
        vx: 0,
        vy: 0,
        ax: 0,
        ay: 0
      });
    }
  }

  createParticles();

  let mouse = { x: null, y: null, radius: 60 };

  fluidCanvas.addEventListener('mousemove', function(e) {
    const rect = fluidCanvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
  });

  fluidCanvas.addEventListener('mouseleave', function() {
    mouse.x = null;
    mouse.y = null;
  });

  function animate() {
    fluidCtx.clearRect(0, 0, fluidCanvas.width, fluidCanvas.height);

    particles.forEach(particle => {
      if (mouse.x !== null && mouse.y !== null) {
        const dx = mouse.x - particle.x;
        const dy = mouse.y - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < mouse.radius) {
          const force = (mouse.radius - distance) / mouse.radius;
          particle.ax = -dx * force * 0.2;
          particle.ay = -dy * force * 0.2;
        }
      }

      particle.vx += particle.ax;
      particle.vy += particle.ay;
      particle.vx *= 0.95;
      particle.vy *= 0.95;
      particle.ax = 0;
      particle.ay = 0;

      if (particle.x < 0 || particle.x > fluidCanvas.width) particle.vx *= -0.5;
      if (particle.y < 0 || particle.y > fluidCanvas.height) particle.vy *= -0.5;

      particle.x += particle.vx;
      particle.y += particle.vy;

      fluidCtx.beginPath();
      fluidCtx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
      fluidCtx.fillStyle = particle.color;
      fluidCtx.fill();
    });

    requestAnimationFrame(animate);
  }

  animate();

  // Setup theme change listeners
  setupThemeChangeListener(() => {
    colors = getThemeColors();
    rigidBeam.color = colors.rigid;
    flexibleBeam.color = colors.flexible;
    draw();
    createParticles();
  });

  // Add captions
  const beamCaption = document.createElement('p');
  beamCaption.className = "font-libre-baskerville text-sm text-gray-600 dark:text-gray-400 italic my-1.5";
  beamCaption.textContent = "Use the slider to increase force on both structures. The rigid structure maintains its shape with minimal deflection until reaching a critical point, after which it fails catastrophically. The flexible structure bends considerably more under the same force but maintains its integrity even under extreme stress.";
  beamContainer.parentNode.insertBefore(beamCaption, beamContainer.nextSibling);

  const fluidCaption = document.createElement('p');
  fluidCaption.className = "font-libre-baskerville text-sm text-gray-600 dark:text-gray-400 italic my-1.5";
  fluidCaption.textContent = "Move your mouse over the simulation to see how particles flow and adapt like a fluid around disturbances. This simple physics model illustrates how fluids respond to external forces by yielding and flowing rather than resisting.";
  fluidContainer.parentNode.insertBefore(fluidCaption, fluidContainer.nextSibling);

  // Initial draw
  draw();
});
</script>
